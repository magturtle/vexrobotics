#pragma config(Motor,  port2,           frontright,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           frontleft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           backleft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           upDownArm,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLeftArm,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           inOutArm,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backright,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c" //MUST HAVE!!!!!!!!

void pre_auton ()//must have
{

}

void drive (int power)//auto drive train powers
{
	motor[frontright] = -power;
	motor[backright] = -power;
	motor[frontleft] = -power;
	motor[backleft] = -power;
}

/*task autonomous()
{
drive(-127);
wait1Msec(1000);
drive(0);
}*/ //drives straight for blocking opposing robots

void drive_right (int power)//auto right turn drive code
{
	motor[frontright] = power;
	motor[backright] = power;
}

task autonomous()//needs so much fixing!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
{
	motor[left] = 100;//down mobile goal
	motor[right] = 100;
	wait1Msec(400);
	motor[left] = 0;
	motor[right] = 0;

	drive(-127);//forward
	wait1Msec(1600);
	drive(0);

	motor[right] = -127;//pick up mobile goal
	motor[left] = -127;
	wait1Msec(500);
	motor[right] = -60;
	motor[left] = -60;

	drive(127);//move back
	wait1Msec(3000);//change
	drive(0);

	drive_right(100);//turn right
	wait1Msec(1500);
	drive_right(0);

	motor[left] = 0;//down pick up
	motor[right] = 0;

	drive(127);
	wait1Msec(1000);
	drive(0);

}

task usercontrol ()
{
	while (true)
	{
		{
			if (vexRT [Btn7U] || vexRT [Btn7UXmtr2]){ //up mobile goals
				motor[right] = -125;
				motor[left] = -125;
				}else if (vexRT [Btn7D] || vexRT [Btn7DXmtr2] ){ //down mobile goals
				motor[right] = 90;
				motor[left] = 90;
				}else{
				motor [right] = 0;//neutral mobil goals (no press of button)
				motor[left] = 0;
			}

			{
				if (vexRT [Btn8U] || vexRT [Btn8UXmtr2]) {//up cones
					motor[upDownArm] = -90;
					}else if (vexRT [Btn8D] || vexRT [Btn8DXmtr2]) {//down cones
					motor [upDownArm] = 30;
					}else{
					motor [upDownArm] = 0;//neutral cones
				}

				{
					if (vexRT [Btn8R] || vexRT [Btn8RXmtr2]) {//turn cones right
						motor[rightLeftArm] = 50;
						}else if (vexRT [Btn8L] || vexRT [Btn8LXmtr2]) {//turn cones left
						motor [rightLeftArm] = -50;
						}else{
						motor [rightLeftArm] = 0;
					}

					{
						if (vexRT [Btn6U] || vexRT [Btn6UXmtr2]) {//in arm
							motor[inOutArm] = 90;
							}else if (vexRT [Btn5U] || vexRT [Btn5UXmtr2]) {//out arm
							motor [inOutArm] = -90;
							}else{
							motor [inOutArm] = 0;
						}

						motor[frontright] = vexRT[Ch3] - vexRT[Ch1];//drive train (all four of these lines)
						motor[backright] = vexRT[Ch3] - vexRT[Ch1];
						motor[frontleft] = vexRT[Ch3] + vexRT[Ch1];
						motor[backleft] = vexRT[Ch3] + vexRT[Ch1];
					}
				}
			}
		}
	}
}
// crazy amount of brackets; if problems with brackets always add more before taking some away
